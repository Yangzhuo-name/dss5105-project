# quick_grid_search.py
"""
å¿«é€Ÿç½‘æ ¼æœç´¢ï¼šåªæµ‹è¯•æœ€é‡è¦çš„å‚æ•°
é¢„è®¡è€—æ—¶ï¼š1-1.5å°æ—¶
"""
# ===== åŠ è¿™3è¡Œ =====
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)
os.chdir(project_root)

import os
import sys
import shutil
import json
from datetime import datetime
from itertools import product

# æµ‹è¯•ç”¨ä¾‹ï¼ˆäºŒåˆ†ç±»ï¼‰
TEST_CASES = {
    "CanAnswer": [
        "When is my rent due each month?",
        "What is the security deposit amount?",
        "Who pays for electricity and water?",
        "What's the diplomatic clause?",
        "Who is responsible for air conditioning maintenance?",
        "Can I keep pets?",
        "Who pays for repairs under $200?",
        "Can I install a dishwasher?",
        "What if the aircon breaks during the first week?",
    ],
    
    "CannotAnswer": [
        "What's the best internet service provider in Singapore?",
        "How do I apply for a work permit?",
        "Where can I buy furniture nearby?",
        "What's the weather like in Singapore?",
        "How do I open a bank account in DBS?",
        "Which primary school is good for my children?",
        "Where is the nearest MRT station?",
    ]
}

# ========== å¿«é€Ÿå‚æ•°ç½‘æ ¼ï¼ˆåªæœç´¢å…³é”®å‚æ•°ï¼‰==========
PARAM_GRID = {
    # æœ€é‡è¦ï¼šé˜ˆå€¼
    'threshold': [0.70, 0.72, 0.75, 0.78, 0.80, 0.82, 0.85],
    
    # æ¬¡é‡è¦ï¼šchunkå‚æ•°
    'chunk_size': [450, 500, 600],
    'chunk_overlap': [100, 150],
    
    # å›ºå®šå‚æ•°ï¼ˆä¸æœç´¢ï¼‰
    'top_k_retrieval': 10,  # å›ºå®š
    'use_mmr': False,       # å›ºå®š
}

def update_config(chunk_size, chunk_overlap, threshold):
    """æ›´æ–°config"""
    config_content = f"""# src/config.py - AUTO GENERATED BY QUICK GRID SEARCH
import os
from dotenv import load_dotenv

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("Missing OPENAI_API_KEY")

EMBEDDING_MODEL = "text-embedding-3-small"
CHAT_MODEL = "gpt-4o-mini"

# Chunking parameters
CHUNK_SIZE = {chunk_size}
CHUNK_OVERLAP = {chunk_overlap}

# Retrieval parameters (FIXED)
TOP_K_RETRIEVAL = 10
TOP_K_CONTEXT = 3
USE_MMR = False
MMR_LAMBDA = 0.7

# Confidence threshold (BINARY CLASSIFICATION)
THRESHOLD_CAN_ANSWER = {threshold}
"""
    
    with open('src/config.py', 'w', encoding='utf-8') as f:
        f.write(config_content)


def rebuild_vector_store():
    """é‡å»ºå‘é‡å­˜å‚¨"""
    print("    ğŸ”¨ é‡å»ºå‘é‡å­˜å‚¨...")
    if os.path.exists('vector_store'):
        shutil.rmtree('vector_store')
    os.system('python -m src.embedder > /dev/null 2>&1')


def test_configuration():
    """æµ‹è¯•å½“å‰é…ç½®"""
    from src.chat import ask
    
    results = []
    correct = 0
    total = sum(len(questions) for questions in TEST_CASES.values())
    
    for expected, questions in TEST_CASES.items():
        for question in questions:
            try:
                response = ask(question)
                
                can_answer = response.get('can_answer', True)
                predicted = 'CanAnswer' if can_answer else 'CannotAnswer'
                
                is_correct = (predicted == expected)
                if is_correct:
                    correct += 1
                
                results.append({
                    'question': question,
                    'expected': expected,
                    'predicted': predicted,
                    'correct': is_correct,
                    'score': response.get('score', 1.0)
                })
                
            except Exception as e:
                results.append({
                    'question': question,
                    'expected': expected,
                    'predicted': 'Error',
                    'correct': False,
                    'error': str(e)
                })
    
    accuracy = (correct / total) * 100
    
    # åˆ†ç±»åˆ«å‡†ç¡®ç‡
    can_results = [r for r in results if r['expected'] == 'CanAnswer']
    cannot_results = [r for r in results if r['expected'] == 'CannotAnswer']
    
    can_acc = sum(1 for r in can_results if r['correct']) / len(can_results) * 100
    cannot_acc = sum(1 for r in cannot_results if r['correct']) / len(cannot_results) * 100
    
    return {
        'accuracy': accuracy,
        'can_answer_accuracy': can_acc,
        'cannot_answer_accuracy': cannot_acc,
        'correct': correct,
        'total': total,
        'results': results
    }


def main():
    print("="*80)
    print("âš¡ å¿«é€Ÿç½‘æ ¼æœç´¢")
    print("="*80)
    
    # è®¡ç®—æ€»ç»„åˆæ•°
    total_combos = (
        len(PARAM_GRID['threshold']) *
        len(PARAM_GRID['chunk_size']) *
        len(PARAM_GRID['chunk_overlap'])
    )
    
    print(f"\nğŸ“Š å‚æ•°ç©ºé—´:")
    print(f"  Threshold: {PARAM_GRID['threshold']}")
    print(f"  Chunk size: {PARAM_GRID['chunk_size']}")
    print(f"  Chunk overlap: {PARAM_GRID['chunk_overlap']}")
    print(f"\n  (Top-K={PARAM_GRID['top_k_retrieval']}, MMR={PARAM_GRID['use_mmr']} å›ºå®šä¸æœç´¢)")
    
    print(f"\nğŸ“ˆ æ€»ç»„åˆæ•°: {total_combos}")
    print(f"â±ï¸  é¢„è®¡è€—æ—¶: {total_combos * 1.5:.0f} åˆ†é’Ÿ (~{total_combos * 1.5 / 60:.1f} å°æ—¶)")
    
    input("\næŒ‰Enterå¼€å§‹æœç´¢ (æˆ–Ctrl+Cå–æ¶ˆ)...")
    
    # å¤‡ä»½åŸå§‹config
    if os.path.exists('src/config.py'):
        shutil.copy('src/config.py', 'src/config.py.backup')
        print("âœ… å·²å¤‡ä»½åŸå§‹é…ç½®")
    
    all_results = []
    current = 0
    last_chunk_params = (None, None)
    
    start_time = datetime.now()
    
    # éå†ç»„åˆï¼ˆchunkå‚æ•°åœ¨å¤–å±‚ï¼Œå‡å°‘é‡å»ºæ¬¡æ•°ï¼‰
    for chunk_size, chunk_overlap in product(PARAM_GRID['chunk_size'], PARAM_GRID['chunk_overlap']):
        
        # åˆ¤æ–­æ˜¯å¦éœ€è¦é‡å»ºå‘é‡å­˜å‚¨
        needs_rebuild = (last_chunk_params != (chunk_size, chunk_overlap))
        
        if needs_rebuild:
            print(f"\n{'='*80}")
            print(f"ğŸ“¦ Chunké…ç½®: size={chunk_size}, overlap={chunk_overlap}")
            print("="*80)
            
            # æ›´æ–°configï¼ˆç”¨ä»»æ„thresholdï¼Œåæ­£è¦é‡å»ºï¼‰
            update_config(chunk_size, chunk_overlap, 0.75)
            rebuild_vector_store()
            last_chunk_params = (chunk_size, chunk_overlap)
        
        # éå†ä¸åŒé˜ˆå€¼ï¼ˆä¸éœ€è¦é‡å»ºï¼‰
        for threshold in PARAM_GRID['threshold']:
            current += 1
            
            print(f"\n[{current}/{total_combos}] threshold={threshold:.2f} ", end="")
            
            # æ›´æ–°configï¼ˆåªæ”¹é˜ˆå€¼ï¼‰
            update_config(chunk_size, chunk_overlap, threshold)
            
            # æµ‹è¯•
            test_result = test_configuration()
            
            result = {
                'params': {
                    'chunk_size': chunk_size,
                    'chunk_overlap': chunk_overlap,
                    'threshold': threshold
                },
                'accuracy': test_result['accuracy'],
                'can_answer_accuracy': test_result['can_answer_accuracy'],
                'cannot_answer_accuracy': test_result['cannot_answer_accuracy'],
                'correct': test_result['correct'],
                'total': test_result['total']
            }
            
            all_results.append(result)
            
            print(f"â†’ {test_result['accuracy']:.1f}% (Can:{test_result['can_answer_accuracy']:.0f}%, Cannot:{test_result['cannot_answer_accuracy']:.0f}%)")
    
    elapsed = (datetime.now() - start_time).total_seconds() / 60
    
    # æ’åºç»“æœ
    print(f"\n{'='*80}")
    print("ğŸ† TOP 10 æœ€ä½³é…ç½®")
    print("="*80)
    
    all_results_sorted = sorted(all_results, key=lambda x: x['accuracy'], reverse=True)
    
    for i, result in enumerate(all_results_sorted[:10], 1):
        params = result['params']
        print(f"\nã€ç¬¬ {i} åã€‘å‡†ç¡®ç‡: {result['accuracy']:.1f}%")
        print(f"  å‚æ•°:")
        print(f"    chunk_size: {params['chunk_size']}")
        print(f"    chunk_overlap: {params['chunk_overlap']}")
        print(f"    threshold: {params['threshold']}")
        print(f"  åˆ†ç±»å‡†ç¡®ç‡:")
        print(f"    CanAnswer: {result['can_answer_accuracy']:.1f}%")
        print(f"    CannotAnswer: {result['cannot_answer_accuracy']:.1f}%")
    
    # ä¿å­˜ç»“æœ
    os.makedirs('grid_search_results', exist_ok=True)
    output_file = f'grid_search_results/quick_search_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
    
    output = {
        'test_time': datetime.now().isoformat(),
        'elapsed_minutes': elapsed,
        'total_combinations': len(all_results),
        'param_grid': PARAM_GRID,
        'all_results': all_results_sorted
    }
    
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(output, f, indent=2, ensure_ascii=False)
    
    print(f"\n{'='*80}")
    print(f"ğŸ’¾ å®Œæ•´ç»“æœ: {output_file}")
    print(f"â±ï¸  å®é™…è€—æ—¶: {elapsed:.1f} åˆ†é’Ÿ")
    print("="*80)
    
    # æ¢å¤åŸå§‹config
    if os.path.exists('src/config.py.backup'):
        shutil.copy('src/config.py.backup', 'src/config.py')
        print("\nâœ… å·²æ¢å¤åŸå§‹é…ç½®")
    
    # ç”Ÿæˆæœ€ä¼˜é…ç½®
    best = all_results_sorted[0]
    optimal_config = f"""# OPTIMAL CONFIG (Quick Grid Search)
# Accuracy: {best['accuracy']:.1f}%
# CanAnswer: {best['can_answer_accuracy']:.1f}%
# CannotAnswer: {best['cannot_answer_accuracy']:.1f}%

CHUNK_SIZE = {best['params']['chunk_size']}
CHUNK_OVERLAP = {best['params']['chunk_overlap']}
THRESHOLD_CAN_ANSWER = {best['params']['threshold']}

# Fixed parameters
TOP_K_RETRIEVAL = 10
USE_MMR = False
"""
    
    optimal_file = 'grid_search_results/optimal_config_quick.txt'
    with open(optimal_file, 'w') as f:
        f.write(optimal_config)
    
    print(f"âœ… æœ€ä¼˜é…ç½®: {optimal_file}")
    print("\nä½¿ç”¨æ–¹æ³•:")
    print(f"  1. æŸ¥çœ‹ {optimal_file}")
    print(f"  2. æ‰‹åŠ¨æ›´æ–° src/config.py")
    print(f"  3. é‡å»ºå‘é‡å­˜å‚¨: rm -rf vector_store && python -m src.embedder")
    print(f"  4. æµ‹è¯•: python test_classification.py")


if __name__ == "__main__":
    main()